#pragma warning disable

namespace Eduard.Cryptography
{
    /* Chudnovsky–Chudnovsky (1986). "Sequences of numbers generated by addition in formal groups and new primality and factorization tests", pp. 385-434 */
    public static class JacobianChudnovskyMath
    {
        public static JacobianChudnovskyPoint Add(EllipticCurve curve, JacobianChudnovskyPoint left, JacobianChudnovskyPoint right)
        {
            if (left == JacobianChudnovskyPoint.POINT_INFINITY) return right;
            if (right == JacobianChudnovskyPoint.POINT_INFINITY) return left;
            BigInteger p = curve.field;

            BigInteger A1 = (left.x * right.z2) % p;
            BigInteger A2 = (right.x * left.z2) % p;

            BigInteger A3 = (left.y * right.z3) % p;
            BigInteger A4 = (right.y * left.z3) % p;

            BigInteger A5 = A2 - A1;
            if (A5 < 0) A5 += p;

            BigInteger A6 = A4 - A3;
            if (A6 < 0) A6 += p;

            BigInteger A7 = (A5 * A5) % p;
            BigInteger A8 = (A5 * A7) % p;

            BigInteger A9 = (A1 * A7) % p;
            BigInteger X = (((A6 * A6) % p) - A8 - 2 * A9) % p;
            if (X < 0) X += p;

            BigInteger Y = (((A6 * (A9 - X)) % p) - A3 * A8) % p;
            if (Y < 0) Y += p;

            BigInteger Z = (((left.z * right.z) % p) * A5) % p;
            BigInteger Z2 = (Z * Z) % p;

            BigInteger Z3 = (Z2 * Z) % p;
            return new JacobianChudnovskyPoint(X, Y, Z, Z2, Z3);
        }

        public static JacobianChudnovskyPoint Doubling(EllipticCurve curve, JacobianChudnovskyPoint jacobianPoint)
        {
            if (jacobianPoint == JacobianChudnovskyPoint.POINT_INFINITY) return JacobianChudnovskyPoint.POINT_INFINITY;
            BigInteger p = curve.field;

            BigInteger A1 = (jacobianPoint.y * jacobianPoint.y) % p;
            BigInteger A2 = (4 * jacobianPoint.x * A1) % p;

            BigInteger A3 = (8 * A1 * A1) % p;
            BigInteger A4 = 0;

            if (curve.a != p - 3)
                A4 = ((3 * jacobianPoint.x * jacobianPoint.x) % p + (curve.a * ((jacobianPoint.z2 * jacobianPoint.z2) % p)) % p) % p;
            else
            {
                /* special case when Weierstrass curve parameter a = -3 */
                A4 = (3 * (jacobianPoint.x - jacobianPoint.z2) * (jacobianPoint.x - jacobianPoint.z2)) % p;
            }

            BigInteger X = ((A4 * A4) % p - 2 * A2) % p;
            if (X < 0) X += p;

            BigInteger Y = (A4 * (A2 - X) - A3) % p;
            if (Y < 0) Y += p;

            BigInteger Z = (2 * jacobianPoint.y * jacobianPoint.z) % p;
            BigInteger Z2 = (Z * Z) % p;

            BigInteger Z3 = (Z2 * Z) % p;
            return new JacobianChudnovskyPoint(X, Y, Z, Z2, Z3);
        }

        public static JacobianChudnovskyPoint Negate(EllipticCurve curve, JacobianChudnovskyPoint point)
        {
            if (point == JacobianChudnovskyPoint.POINT_INFINITY) return JacobianChudnovskyPoint.POINT_INFINITY;
            return new JacobianChudnovskyPoint(point.x, curve.field - point.y, point.z, point.z2, point.z3);
        }
    }
}
